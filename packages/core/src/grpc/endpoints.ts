/**
 * Network Endpoint Configuration for Aura Blockchain
 *
 * Defines endpoints and chain IDs for different Aura networks.
 */

/**
 * Network configuration interface
 */
export interface NetworkConfig {
  /** gRPC endpoint URL */
  grpc: string;
  /** REST API endpoint URL */
  rest: string;
  /** Cosmos chain ID */
  chainId: string;
}

/**
 * Aura network configurations
 *
 * Security:
 * - Mainnet and testnet use TLS-secured endpoints (HTTPS/gRPCS)
 * - gRPC endpoints use port 443 with TLS by default
 * - Local network allows insecure connections for development only
 */
export const AURA_NETWORKS: Record<'mainnet' | 'testnet' | 'local', NetworkConfig> = {
  /**
   * Aura Mainnet (Production)
   * Security: TLS required for all connections
   * Note: Mainnet endpoints are TBD
   */
  mainnet: {
    grpc: 'grpcs://mainnet-rpc.aurablockchain.org:443', // TBD
    rest: 'https://mainnet-api.aurablockchain.org', // TBD
    chainId: 'aura-mainnet-1',
  },

  /**
   * Aura Testnet (MVP)
   * Security: TLS required for all connections
   */
  testnet: {
    grpc: 'grpcs://testnet-grpc.aurablockchain.org:443',
    rest: 'https://testnet-api.aurablockchain.org',
    chainId: 'aura-mvp-1',
  },

  /**
   * Local Development Network
   * Security: Insecure connections allowed for localhost only
   */
  local: {
    grpc: 'grpc://localhost:9090',
    rest: 'http://localhost:1317',
    chainId: 'aura-local-test',
  },
};

/**
 * REST API endpoint paths
 * These paths are auto-generated by Cosmos SDK gRPC-gateway from proto definitions
 */
export const API_PATHS = {
  /**
   * VC Registry module endpoints (aura.vcregistry.v1beta1.Query)
   */
  vcregistry: {
    /** Get VC by ID - maps to Query.GetVC */
    getVC: (vcId: string) => `/aura/vcregistry/v1beta1/vcs/${encodeURIComponent(vcId)}`,
    /** Check VC status - maps to Query.CheckVCStatus */
    checkVCStatus: (vcId: string) => `/aura/vcregistry/v1beta1/vcs/${encodeURIComponent(vcId)}/status`,
    /** Batch check VC status - maps to Query.BatchVCStatus (POST) */
    batchVCStatus: '/aura/vcregistry/v1beta1/vcs/batch_status',
    /** List VCs by holder - maps to Query.ListUserVCs */
    listUserVCs: (holderAddress: string) => `/aura/vcregistry/v1beta1/vcs/user/${encodeURIComponent(holderAddress)}`,
    /** Get VC policy - maps to Query.GetVCPolicy */
    getVCPolicy: (vcTypeName: string) => `/aura/vcregistry/v1beta1/policies/${encodeURIComponent(vcTypeName)}`,
    /** List VC policies - maps to Query.ListVCPolicies */
    listVCPolicies: '/aura/vcregistry/v1beta1/policies',
    /** Get revocation list - maps to Query.GetRevocationList */
    getRevocationList: '/aura/vcregistry/v1beta1/revocations',
    /** Check revocation - maps to Query.CheckRevocation */
    checkRevocation: (vcId: string) => `/aura/vcregistry/v1beta1/revocations/${encodeURIComponent(vcId)}`,
    /** Resolve DID - maps to Query.ResolveDID */
    resolveDID: (did: string) => `/aura/vcregistry/v1beta1/dids/${encodeURIComponent(did)}`,
    /** Get DID by address - maps to Query.GetDIDByAddress */
    getDIDByAddress: (controller: string) => `/aura/vcregistry/v1beta1/dids/address/${encodeURIComponent(controller)}`,
    /** Validate mint eligibility - maps to Query.ValidateMintEligibility */
    validateMintEligibility: (holderAddress: string, vcType: number) =>
      `/aura/vcregistry/v1beta1/eligibility/${encodeURIComponent(holderAddress)}/${vcType}`,
    /** Get registry stats - maps to Query.Stats */
    stats: '/aura/vcregistry/v1beta1/stats',
    /** Get module params - maps to Query.Params */
    params: '/aura/vcregistry/v1beta1/params',
    /** Get attribute VC - maps to Query.GetAttributeVC */
    getAttributeVC: (attributeVcId: string) => `/aura/vcregistry/v1beta1/attributes/${encodeURIComponent(attributeVcId)}`,
    /** List attribute VCs - maps to Query.ListAttributeVCs */
    listAttributeVCs: (holderAddress: string) => `/aura/vcregistry/v1beta1/attributes/user/${encodeURIComponent(holderAddress)}`,
    /** Get disclosure policy - maps to Query.GetDisclosurePolicy */
    getDisclosurePolicy: (holderAddress: string) => `/aura/vcregistry/v1beta1/disclosure/policy/${encodeURIComponent(holderAddress)}`,
    /** Get disclosure request - maps to Query.GetDisclosureRequest */
    getDisclosureRequest: (requestId: string) => `/aura/vcregistry/v1beta1/disclosure/requests/${encodeURIComponent(requestId)}`,
  },

  /**
   * Identity module endpoints (aura.identity.v1beta1.Query)
   */
  identity: {
    /** Get identity by DID - maps to Query.IdentityRecord */
    getIdentity: (did: string) => `/aura/identity/v1beta1/identities/${encodeURIComponent(did)}`,
    /** Get identity by address - maps to Query.IdentityRecordByAddress */
    getIdentityByAddress: (address: string) => `/aura/identity/v1beta1/identities/address/${encodeURIComponent(address)}`,
    /** List all identities - maps to Query.AllIdentityRecords */
    listIdentities: '/aura/identity/v1beta1/identities',
    /** Get change request - maps to Query.ChangeRequest */
    getChangeRequest: (requestId: string) => `/aura/identity/v1beta1/change-requests/${encodeURIComponent(requestId)}`,
    /** Get change requests by DID - maps to Query.ChangeRequestsByDID */
    getChangeRequestsByDID: (did: string) => `/aura/identity/v1beta1/change-requests/did/${encodeURIComponent(did)}`,
    /** Get change history - maps to Query.ChangeHistory */
    getChangeHistory: (did: string) => `/aura/identity/v1beta1/change-history/${encodeURIComponent(did)}`,
    /** Get role - maps to Query.Role */
    getRole: (roleName: string) => `/aura/identity/v1beta1/roles/${encodeURIComponent(roleName)}`,
    /** List all roles - maps to Query.AllRoles */
    listRoles: '/aura/identity/v1beta1/roles',
    /** Get role assignments - maps to Query.RoleAssignments */
    getRoleAssignments: (address: string) => `/aura/identity/v1beta1/role-assignments/${encodeURIComponent(address)}`,
    /** Check permission - maps to Query.HasPermission */
    hasPermission: (address: string, permission: string) =>
      `/aura/identity/v1beta1/permissions/${encodeURIComponent(address)}/${encodeURIComponent(permission)}`,
    /** Get session - maps to Query.Session */
    getSession: (sessionId: string) => `/aura/identity/v1beta1/sessions/${encodeURIComponent(sessionId)}`,
    /** Get sessions by address - maps to Query.SessionsByAddress */
    getSessionsByAddress: (address: string) => `/aura/identity/v1beta1/sessions/address/${encodeURIComponent(address)}`,
    /** Get audit logs - maps to Query.AuditLogs */
    getAuditLogs: '/aura/identity/v1beta1/audit-logs',
    /** Get audit logs by actor - maps to Query.AuditLogsByActor */
    getAuditLogsByActor: (actor: string) => `/aura/identity/v1beta1/audit-logs/actor/${encodeURIComponent(actor)}`,
    /** Get module params - maps to Query.Params */
    params: '/aura/identity/v1beta1/params',
  },

  /**
   * Chain info endpoints (Cosmos SDK standard)
   */
  chain: {
    /** Get node info */
    nodeInfo: '/cosmos/base/tendermint/v1beta1/node_info',
    /** Get latest block */
    latestBlock: '/cosmos/base/tendermint/v1beta1/blocks/latest',
    /** Get syncing status */
    syncing: '/cosmos/base/tendermint/v1beta1/syncing',
    /** Get block by height */
    blockByHeight: (height: number) => `/cosmos/base/tendermint/v1beta1/blocks/${height}`,
  },
};

/**
 * Get network configuration by name
 */
export function getNetworkConfig(network: 'mainnet' | 'testnet' | 'local'): NetworkConfig {
  return AURA_NETWORKS[network];
}

/**
 * Validate network name
 */
export function isValidNetwork(network: string): network is 'mainnet' | 'testnet' | 'local' {
  return network === 'mainnet' || network === 'testnet' || network === 'local';
}

/**
 * Build full REST endpoint URL
 */
export function buildEndpointURL(baseURL: string, path: string): string {
  // Remove trailing slash from base URL
  const base = baseURL.replace(/\/+$/, '');
  // Ensure path starts with slash
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  return `${base}${normalizedPath}`;
}

/**
 * Security: Validate that endpoint uses TLS (HTTPS)
 * @param endpoint - URL to validate
 * @param allowInsecureLocal - Allow HTTP for localhost only (default: false)
 * @returns true if secure, throws otherwise
 */
export function validateTLSEndpoint(
  endpoint: string,
  allowInsecureLocal: boolean = false
): boolean {
  const url = new URL(endpoint);

  // HTTPS is always allowed
  if (url.protocol === 'https:') {
    return true;
  }

  // HTTP only allowed for localhost in development
  if (url.protocol === 'http:') {
    const isLocalhost = url.hostname === 'localhost' ||
                        url.hostname === '127.0.0.1' ||
                        url.hostname === '::1';

    if (isLocalhost && allowInsecureLocal) {
      return true;
    }

    throw new Error(
      `Security: TLS required. Endpoint "${endpoint}" must use HTTPS. ` +
      `HTTP is only allowed for localhost in development mode.`
    );
  }

  throw new Error(`Unsupported protocol: ${url.protocol}`);
}

/**
 * Security: Validate gRPC endpoint format and TLS requirements
 *
 * Production gRPC MUST use TLS (grpcs:// protocol or port 443)
 * @param endpoint - gRPC endpoint URL (e.g., grpcs://rpc.aurablockchain.org:443)
 * @param network - Network type (mainnet, testnet, local)
 * @param allowInsecure - Allow insecure connections (default: false, only for local)
 * @returns true if valid, throws SecurityError otherwise
 */
export function validateGRPCEndpoint(
  endpoint: string,
  network: 'mainnet' | 'testnet' | 'local',
  allowInsecure: boolean = false
): boolean {
  // Parse the endpoint
  const grpcsMatch = endpoint.match(/^grpcs:\/\/(.+):(\d+)$/);
  const grpcMatch = endpoint.match(/^grpc:\/\/(.+):(\d+)$/);
  const legacyMatch = endpoint.match(/^([^:]+):(\d+)$/);

  // Check for grpcs:// (secure gRPC with TLS)
  if (grpcsMatch) {
    return true; // TLS is explicitly enabled
  }

  // Check for grpc:// (insecure gRPC)
  if (grpcMatch) {
    const host = grpcMatch[1];
    const isLocalhost = host === 'localhost' || host === '127.0.0.1' || host === '::1';

    if (network === 'local' && isLocalhost) {
      return true; // Insecure localhost is allowed for local network
    }

    if (allowInsecure && isLocalhost) {
      console.warn(
        `[Security Warning] Allowing insecure gRPC connection to ${endpoint}. ` +
        `This should only be used for local development.`
      );
      return true;
    }

    throw new Error(
      `Security: TLS required for gRPC. Endpoint "${endpoint}" uses insecure grpc:// protocol. ` +
      `Use grpcs:// for secure connections to non-local networks.`
    );
  }

  // Legacy format without protocol (e.g., "rpc.aurablockchain.org:9090")
  if (legacyMatch) {
    const host = legacyMatch[1];
    const port = parseInt(legacyMatch[2], 10);
    const isLocalhost = host === 'localhost' || host === '127.0.0.1' || host === '::1';

    // Local network with localhost is allowed
    if (network === 'local' && isLocalhost) {
      console.warn(
        `[Security] Legacy gRPC endpoint format "${endpoint}". ` +
        `Consider using grpc://localhost:${port} for clarity.`
      );
      return true;
    }

    // For non-local networks, require explicit protocol
    throw new Error(
      `Security: Ambiguous gRPC endpoint "${endpoint}". ` +
      `Use grpcs://${host}:${port} for TLS-secured connections, ` +
      `or grpc://${host}:${port} for insecure (local only).`
    );
  }

  throw new Error(
    `Invalid gRPC endpoint format: "${endpoint}". ` +
    `Expected format: grpcs://host:port or grpc://host:port`
  );
}

/**
 * Get secure network configuration
 * Security: Validates TLS requirements for non-local networks
 */
export function getSecureNetworkConfig(
  network: 'mainnet' | 'testnet' | 'local',
  options: { allowInsecureLocal?: boolean } = {}
): NetworkConfig {
  const config = AURA_NETWORKS[network];

  // Validate TLS for non-local networks
  if (network !== 'local') {
    validateTLSEndpoint(config.rest, false);
    validateGRPCEndpoint(config.grpc, network);
  } else if (options.allowInsecureLocal) {
    // Local is explicitly allowed
    validateTLSEndpoint(config.rest, true);
  }

  return config;
}

/**
 * Default retry configuration
 */
export const DEFAULT_RETRY_CONFIG = {
  maxAttempts: 3,
  initialDelay: 1000, // 1 second
  maxDelay: 10000, // 10 seconds
  backoffMultiplier: 2,
  retryOnTimeout: true,
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
};

/**
 * Default timeout in milliseconds
 */
export const DEFAULT_TIMEOUT = 10000; // 10 seconds

/**
 * Default connection timeout in milliseconds
 */
export const DEFAULT_CONNECT_TIMEOUT = 5000; // 5 seconds

/**
 * Batch query limits
 */
export const BATCH_LIMITS = {
  /** Maximum VCs to query in single batch */
  maxBatchSize: 100,
  /** Concurrent requests in batch */
  concurrentRequests: 10,
};
